#include "cppdefs.h"
                                      ! Read and report model input
      subroutine read_inp (ierr)      ! parameters from keyword-based 
      implicit none                   ! startup file.
#include "param.h"
#include "scoord.h"
#include "scalars.h"
#include "ncvars.h"
#include "boundary.h"
#ifndef NONLIN_EOS
# include "eos_vars.h"
#endif
#ifdef FLOATS
# include "ncvars_floats.h"
#endif
#ifdef BGC_FLUX_ANALYSIS
# include "bgcflux.h"
# include "ncroms_bgcflux.h"
#endif
#ifdef PHYS_FLUX_ANALYSIS
# include "physflux.h"
# include "ncroms_physflux.h"
#endif
#ifdef MPI
# include "mpif.h"
#endif
#if defined PASSIVE_TRACER && defined AGE_DYE_TRACER
# include "sources.h"
      integer N_agedye_files
#endif
      integer kwsize, testunit, input
      parameter (kwsize=32, testunit=40, input=15)
      character end_signal*3, keyword*32, fname*150
      parameter (end_signal='end')
      integer ierr, iargc, is,ie,  kwlen, lstr, lenstr, i
#ifdef SOLVE3D
     &                                            , itrc
#endif
!DL: variable for varying atm pCO2:
#if (defined BIOLOGY_BEC || defined BIOLOGY_BEC2 || defined BIOLOGY_NPZDOC)\
    && defined VARIABLE_ANN_ATM_PCO2
      logical futr_scen_valid
#endif
      integer*4 ione      ! This is needed to avoid automatic
      parameter (ione=1)  ! promotion to 8-byte integer by
                          ! compiler flag (xlf_r on IBM p690).
!
! Check CPP-switches for consistency. This operation is split into
! two stages because the first subroutine, "check_switches1", is
! generated by special program cppcheck (file cppcheck.F) by
! examining and documention all available switches in cppdefs.h.
! This subroutine creates log of all switches defined in "cppdefs.h",
! as well as traps multiply defined global configurations (project
! switches, such as PACIFIC, USWEST, DAMEE_B, etc).
! The second routine, "check_switches2" is hand written and it
! contains traps for mutually exclussive definition of all other
! CPP-switches (i.e. those which are NOT project selection switches,
! for example, it traps multiply defined vertical mixing schemes or
! lateral boundary conditions).
!
! Both codes are written in transparent mode: they assumed that error
! variable (ierr) is initialized at entry and they add 1 for each
! error discovered.
!
      ierr=0    ! <-- reset error counter
      call check_tiling (ierr)
      call check_switches1 (ierr)
#ifdef SOLVE3D
      call check_rhs3d_switches (ierr)
      call check_trc_adv_switches (ierr)
# ifdef LMD_KPP
      call check_kpp_switches (ierr)  
# endif
#endif
      call check_switches2 (ierr)
      if (ierr.ne.0) return
!
! Use pre-set default startup filename for known applications, or
! get it as an argument from command line via iargc-getarg (override
! default). NOTE: The usage of the executable should be either
!
!              roms 
!        or
!              roms startup_file_name
!
! WITHOUT the UNIX redirection (<): roms < startup_file like it
! used to be.
!
#if defined SOLITON
      fname='roms.in.Soliton'
#elif defined SEAMOUNT
      fname='roms.in.Seamount'
#elif defined WAVE_RAD
      fname='roms.in.WaveRad'
#elif defined ISWAKE
      fname='roms.in.IsWake'
#elif defined UPWELLING
      fname='roms.in.Upwelling'
#elif defined GRAV_ADJ
      fname='roms.in.GravAdj'
#elif defined IBERIA
      fname='roms.in.Iberia'
#elif defined RIVER
      fname='roms.in.River'
#elif defined PACIFIC
      fname='pacific.in'
#elif defined ONE_DIM
      fname='one_dim.in'
#elif defined PACIFIC_2D
      fname='pacific_2D.in'
#elif defined CANBAS2
c--      fname='canBas2.in'
      fname='unpr.in'
c--      fname='cblanco.in'
#elif defined SPIRAL
      fname='spiral.in'
#elif defined PACBIG
      fname='pacbig.in'
#elif defined ATLSMA
      fname='atlsma.in'
#elif defined USWEST
      fname='mb_l1_safe.in'
c--      fname='roms.in.USW20'
c--      fname='roms.in.US_West'
#elif defined USWC_CENTRAL
      fname='usw.in'
#elif defined HBCS60
      fname='hbcs.in'
#elif defined HBCS5
      fname='hbcs5.in'
#elif defined SAWC
      fname='sawc.in'
#elif defined DAMEE_B
      fname='roms.in.Atl4'
#else
      fname='no_startup_file'
#endif
#ifdef MPI
      if (mynode.eq.0 .and. iargc().eq.1) call getarg(ione,fname)
      call MPI_Bcast(fname,150,MPI_BYTE, 0, ocean_grid_comm, ierr)
#else
      if (iargc().eq.1) call getarg(ione,fname)
#endif
      wrthis(indxTime)=.false.
#ifdef AVERAGES
      wrtavg(indxTime)=.false.
#endif
      MPI_master_only print '(/3A)', '------------------'
     &  , ' Reading input parameters ', '------------------'
!
! Read in keyword: keep trying, until keyword is found.
! ==== == ======== ==== ======= ===== ======= == ======
!
      call setup_kwds (ierr)
      open (input,file=fname,status='old',form='formatted',err=97)
   1   keyword='                                '
       read(input,'(A)',err=1,end=99) keyword
       if (ichar(keyword(1:1)).eq.33) goto 1
       is=1
   2   if (is.eq.kwsize) then
         goto 1
       elseif (keyword(is:is).eq.' ') then
         is=is+1
         goto 2
       endif
       ie=is
   3   if (keyword(ie:ie).eq.':') then
         keyword(ie:ie)=' '
         goto 4           !--> recognized keyword.
       elseif (keyword(ie:ie).ne.' ' .and. ie.lt.kwsize) then
         ie=ie+1
         goto 3
       endif
       goto 1
   4   kwlen=ie-is
       if (is.gt.1) keyword(1:kwlen)=keyword(is:is+kwlen-1)
!
! Read input parameters according to the keyword:
! ==== ===== ========== ========= == === ========
!
! Title
!
        if (keyword(1:kwlen).eq.'title') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,'(A)',err=95) title
          lstr=lenstr(title)
          MPI_master_only write(stdout,'(/1x,A)') title(1:lstr)
!
! Time-stepping parameters
!
        elseif (keyword(1:kwlen).eq.'time_stepping') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) ntimes,dt,ndtfast, ninfo
          MPI_master_only write(stdout,
     &    '(I10,2x,A,1x,A/F12.4,1x,A,2(/I10,2x,A,1x,A)/F10.4,2x,A)'
     &    ) ntimes,  'ntimes   Total number of timesteps for',
     &                                              '3D equations.',
     &      dt,      'dt       Timestep [sec] for 3D equations',
     &      ndtfast, 'ndtfast  Number of 2D timesteps within each',
     &                                                   '3D step.',
     &      ninfo,   'ninfo    Number of timesteps between',
     &                                       'runtime diagnostics.'
          dtfast=dt/float(ndtfast)     ! set barotropic time step.
 
#ifdef SOLVE3D
!
! Vertical S-coordinates parameters.
!
        elseif (keyword(1:kwlen) .eq. 'S-coord') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) theta_s, theta_b, hc
          MPI_master_only write(stdout,'(3(1pe10.3,2x,A,1x,A/))')
     &         theta_s, 'theta_s  S-coordinate surface stretching',
     &                                                'parameter.',
     &         theta_b, 'theta_b  S-coordinate bottom stretching',
     &                                                'parameter.',
     &         hc, 'hc       S-coordinate critical depth, meters.'
#endif
!
! Initial conditions file name. Check its availability (in the case
! of analytical initial conditions and nrrec=0 initial conditions are
! created internally and no file is needed).
!
        elseif (keyword(1:kwlen) .eq. 'initial') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) nrrec
#ifdef ANA_INITIAL
          if (nrrec.gt.0) then
#endif
            read(input,'(A)',err=95) fname
            lstr=lenstr(fname)
#if defined MPI && defined PARALLEL_FILES
            call insert_node (fname, lstr, mynode, NNODES, ierr)
#endif
            ininame=fname(1:lstr)
            MPI_master_only write(stdout,'(1x,A,2x,A,4x,A,I3)')
     &       'Initial State File:', ininame(1:lstr), 'Record:',nrrec
#ifdef ANA_INITIAL
          endif
#endif
#ifndef ANA_GRID
!
! Grid file name. Check its availability.
!
        elseif (keyword(1:kwlen) .eq. 'grid') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,'(A)',err=95) fname
          lstr=lenstr(fname)
# if defined MPI && defined PARALLEL_FILES
          call insert_node (fname, lstr, mynode, NNODES, ierr)
# endif
          open(testunit,file=fname(1:lstr), status='old', err=97)
          close(testunit)
          grdname=fname(1:lstr)
          MPI_master_only write(stdout,'(10x,A,2x,A)')
     &                     'Grid File:', grdname(1:lstr)
#endif
#if !defined ANA_SMFLUX  ||  defined SOLVE3D  &&\
   ( !defined ANA_STFLUX  ||\
     (defined SG_BBL96    && !defined ANA_BSEDIM) ||\
     (defined SG_BBL96    && !defined ANA_WWAVE)  ||\
     (defined QCORRECTION && !defined ANA_SST)    ||\
     (defined SALINITY    && !defined ANA_SSFLUX) ||\
     (defined LMD_KPP     && !defined ANA_SRFLUX))
 
!
! Forcing file name. Check its availability.
!
        elseif (keyword(1:kwlen) .eq. 'forcing') then
          call cancel_kwd (keyword(1:kwlen), ierr)


          max_frc=0
          lstr=1
          do while (lstr.gt.0 .and. max_frc.lt.max_frc_file)
            read(input,'(A)',err=95) fname
            lstr=lenstr(fname)
            if (lstr.gt.0) then
#if defined MPI && defined PARALLEL_FILES
              call insert_node (fname, lstr, mynode, NNODES, ierr)
#endif
              open (testunit,file=fname(1:lstr),status='old',err=97)
              close(testunit)
              max_frc=max_frc+1
              frcfile(max_frc)=fname(1:lstr)
              MPI_master_only write(stdout,'(2x,A,2x,A)')
     &          'Forcing Data File:', frcfile(max_frc)(1:lstr)
            endif
          enddo

#endif


!
! Climatology file name. Climatology data is needed for (1) to supply
! boundary data for T,S,u,v at open boundaries (just one row of 
! points); and (2) nudging to T,S data inside the domain within the 
! nudging finite-width band near the boundary [although depreciated, 
! this practice  remains in some applications; doing so for u,v is no
! longer supported by this code].  Aternatively to (1), the boundary
! data may also be supplied via BRY mechanism, where file contains
! perimeter data only.  In this case (activated by T_FRC_BRY), no   
! climatology file is needed.  The following code segments also 
! checks for availability of clm_file.
!
#if defined SOLVE3D &&( defined TCLIMATOLOGY ||( defined TNUDGING &&\
              defined T_FRC_BRY )) && !defined ANA_TCLIMA

        elseif (keyword(1:kwlen).eq.'climatology') then
          call cancel_kwd (keyword(1:kwlen), ierr)
# ifdef MULT_CLIM_FILES
          ! Read number of climatology files:
          read(input,'(i)') nclimfiles
          if (nclimfiles > 4) then
             MPI_master_only write (*,'(a,1x,a)') 'ERROR:',
     &         'at most 4 climatology files are possible.'
             goto 95
          end if
          MPI_master_only write(stdout,'(3x,a,i3)')
     &      'Number of climatology files: ', nclimfiles
          ! Read names of clim files (one per line):
          do i = 1,nclimfiles
             read(input,'(A)',err=95) fname
             lstr=lenstr(fname)
#  if defined MPI && defined PARALLEL_FILES
             call insert_node (fname, lstr, mynode, NNODES, ierr)
#  endif
             open (testunit, file=fname(1:lstr), status='old', err=97)
             close(testunit)
             clm_file(i) = fname(1:lstr)
             MPI_master_only write(stdout,'(3x,A,i3,A,2x,A)')
     &          'Climatology File ',i,':', clm_file(i)(1:lstr)
          end do
# else /* MULT_CLIM_FILES */
          read(input,'(A)',err=95) fname
          lstr=lenstr(fname)
#  if defined MPI && defined PARALLEL_FILES
          call insert_node (fname, lstr, mynode, NNODES, ierr)
#  endif
          open (testunit, file=fname(1:lstr), status='old', err=97)
          close(testunit)
          clm_file=fname(1:lstr)
          MPI_master_only write(stdout,'(3x,A,2x,A)')
     &          'Climatology File:', clm_file(1:lstr)
# endif /* MULT_CLIM_FILES */
#endif /* SOLVE3D &&( defined TCLIMATOLOGY... */

#if defined T_FRC_BRY || defined M2_FRC_BRY || \
    defined M3_FRC_BRY || defined Z_FRC_BRY
# ifndef ANA_BRY
!
! Boundary file name. Check availability.
!
        elseif (keyword(1:kwlen).eq.'boundary') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,'(A)',err=95) fname
          lstr=lenstr(fname)
#  if defined MPI && defined PARALLEL_FILES
          call insert_node (fname, lstr, mynode, NNODES, ierr)
#  endif
          open (testunit, file=fname(1:lstr), status='old', err=97)
          close(testunit)
          bry_file=fname(1:lstr)
          MPI_master_only write(stdout,'(6x,A,2x,A)')
     &          'Boundary File:', bry_file(1:lstr)
# endif
#endif /* SOLVED3D && TCLIMATOLOGY etc. */
!
! Restart file name.
!
        elseif (keyword(1:kwlen).eq.'restart') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) nrst, nrpfrst
          read(input,'(A)',err=95)  fname
          lstr=lenstr(fname)
# if defined MPI && defined PARALLEL_FILES
          call insert_node (fname, lstr, mynode, NNODES, ierr)
# endif
          rstname=fname(1:lstr)
          MPI_master_only write(stdout,
     &               '(7x,A,2x,A,4x,A,I6,4x,A,I4)')
     &               'Restart File:', rstname(1:lstr),
     &               'nrst =', nrst, 'rec/file: ', nrpfrst
!
! History file name.
!
        elseif (keyword(1:kwlen).eq.'history') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) ldefhis, nwrt, nrpfhis
          read(input,'(A)',err=95) fname
          lstr=lenstr(fname)
# if defined MPI && defined PARALLEL_FILES
          call insert_node (fname, lstr, mynode, NNODES, ierr)
# endif
          hisname=fname(1:lstr)
          MPI_master_only write(stdout,
     &               '(7x,A,2x,A,2x,A,1x,L1,2x,A,I5,2x,A,I3)')
     &         'History File:', hisname(1:lstr),  'Create new:',
     &         ldefhis, 'nwrt =', nwrt, 'rec/file =', nrpfhis
#ifdef AVERAGES
!
! Averages file name.
!
        elseif (keyword(1:kwlen).eq.'averages') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) ntsavg, navg, nrpfavg
          read(input,'(A)',err=95) fname
          lstr=lenstr(fname)
# if defined MPI && defined PARALLEL_FILES
          call insert_node (fname, lstr, mynode, NNODES, ierr)
# endif
          avgname=fname(1:lstr)
          MPI_master_only write(stdout,
     &           '(2(I10,2x,A,1x,A/32x,A/),6x,A,2x,A,1x,A,I3)')
     &      ntsavg, 'ntsavg      Starting timestep for the ',
     &           'accumulation of output', 'time-averaged data.',
     &      navg,   'navg        Number of timesteps between',
     &     'writing of time-averaged','data into averages file.',
     &     'Averages File:', avgname(1:lstr),
     &     'rec/file =', nrpfavg
#endif
#ifdef SLICE_AVG
!
! Slice averages file name.
!
        elseif (keyword(1:kwlen).eq.'slice_averages') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) ksl, ntsslavg, nslavg, nrpfslavg
          read(input,'(A)',err=95) fname
          lstr=lenstr(fname)
# if defined MPI && defined PARALLEL_FILES
          call insert_node (fname, lstr, mynode, NNODES, ierr)
# endif
          slavgname=fname(1:lstr)
          MPI_master_only write(stdout,
     &          '(I4,2x,A/2(I10,2x,A,1x,A/32x,A/),6x,A,2x,A,1x,A,I3)')
     &      ksl,      'ksl         Sigma level to average.',
     &      ntsslavg, 'ntsslavg      Starting timestep for the ',
     &          'accumulation of output', 'time-averaged slice data.',
     &      nslavg,   'nslavg        Number of timesteps between',
     &     'writing of time-averaged','data into averages file.',
     &     'Slice averages file:  ', slavgname(1:lstr),
     &     'rec/file =', nrpfslavg
#endif

#ifdef BGC_FLUX_ANALYSIS
!
! File name for histories of biogeochemical fluxes
!
        elseif (keyword(1:kwlen).eq.'bgc_flux_histories') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) new_bgc_flux_his,
     &         n_bgc_flux_his, nrpf_bgc_flux_his
          read(input,'(A)',err=95) fname
          lstr=lenstr(fname)
# if defined MPI && defined PARALLEL_FILES
          call insert_node (fname, lstr, mynode, NNODES, ierr)
# endif
          bgc_flux_his_name=fname(1:lstr)
          MPI_master_only write(stdout,
     &           '(I10,2x,A,1x,A/32x,A/,6x,A,2x,A,1x,A,I3)')
     &      n_bgc_flux_his,   
     &         'n_bgc_flux_his     Number of timesteps between',
     &     'writing of',
     &         ' biogeochemical fluxes into file.',
     &     'Biogeochemical flux file:', 
     &         bgc_flux_his_name(1:lstr),
     &     'rec/file =', nrpf_bgc_flux_his

# ifdef AVERAGES
!
! File name for averages of biogeochemical fluxes
!
        elseif (keyword(1:kwlen).eq.'bgc_flux_averages') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) new_bgc_flux_avg,
     &         nts_bgc_flux_avg, n_bgc_flux_avg, nrpf_bgc_flux_avg
          read(input,'(A)',err=95) fname
          lstr=lenstr(fname)
#  if defined MPI && defined PARALLEL_FILES
          call insert_node (fname, lstr, mynode, NNODES, ierr)
#  endif
          bgc_flux_avg_name=fname(1:lstr)
          MPI_master_only write(stdout,
     &           '(2(I10,2x,A,1x,A/32x,A/),6x,A,2x,A,1x,A,I3)')
     &      nts_bgc_flux_avg, 
     &         'nts_bgc_flux_avg   Starting timestep for the',
     &           ' accumulation of output', 
     &         ' time-averaged biogeochemical fluxes.',
     &      n_bgc_flux_avg,   
     &         'n_bgc_flux_avg     Number of timesteps between',
     &     'writing of',
     &         ' time-averaged biogeochemical fluxes into file.',
     &     'Averaged biogeochemical flux file:', 
     &         bgc_flux_avg_name(1:lstr),
     &     'rec/file =', nrpf_bgc_flux_avg
# endif /* AVERAGES */
#endif /* BGC_FLUX_ANALYSIS */
#ifdef PHYS_FLUX_ANALYSIS
!
! File name for histories of physical fluxes
!
        elseif (keyword(1:kwlen).eq.'phys_flux_histories') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) new_phys_flux_his,
     &         n_phys_flux_his, nrpf_phys_flux_his
          read(input,'(A)',err=95) fname
          lstr=lenstr(fname)
# if defined MPI && defined PARALLEL_FILES
          call insert_node (fname, lstr, mynode, NNODES, ierr)
# endif
          phys_flux_his_name=fname(1:lstr)
          MPI_master_only write(stdout,
     &           '(I10,2x,A,1x,A/32x,A/,6x,A,2x,A,1x,A,I3)')
     &      n_phys_flux_his,
     &         'n_phys_flux_his    Number of timesteps between',
     &     ' writing of',
     &         ' physical fluxes into file.',
     &     'Physical flux file:',
     &         phys_flux_his_name(1:lstr),
     &     'rec/file =', nrpf_phys_flux_his

# ifdef AVERAGES
!
! File name for averages of physical fluxes
!
        elseif (keyword(1:kwlen).eq.'phys_flux_averages') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) new_phys_flux_avg,
     &         nts_phys_flux_avg, n_phys_flux_avg,
     &         nrpf_phys_flux_avg
          read(input,'(A)',err=95) fname
          lstr=lenstr(fname)
#  if defined MPI && defined PARALLEL_FILES
          call insert_node (fname, lstr, mynode, NNODES, ierr)
#  endif
          phys_flux_avg_name=fname(1:lstr)
          MPI_master_only write(stdout,
     &           '(2(I10,2x,A,1x,A/32x,A/),6x,A,2x,A,1x,A,I3)')
     &      nts_phys_flux_avg,
     &         'nts_phys_flux_avg  Starting timestep for the',
     &           ' accumulation of output',
     &         ' time-averaged physical fluxes.',
     &      n_phys_flux_avg,
     &         'n_phys_flux_avg    Number of timesteps between',
     &     ' writing of',
     &         ' time-averaged physical fluxes into file.',
     &     'Averaged physical flux file:',
     &         phys_flux_avg_name(1:lstr),
     &     'rec/file =', nrpf_phys_flux_avg
# endif /* AVERAGES */
#endif /* PHYS_FLUX_ANALYSIS */





#ifdef STATIONS
!
! Stations file name.
!
        elseif (keyword(1:kwlen).eq.'stations') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) nsta
          read(input,'(A)',err=95) sposnam
          read(input,'(A)',err=95) staname
 
          fname=sposnam
          lstr=lenstr(fname)
          open (testunit,file=fname(1:lstr),status='old',err=97)
          close(testunit)
          MPI_master_only write(stdout,
     &       '(I10,2x,A,1x,A/32x,A/1x,A,2x,A)')
     &         nsta,  'nsta        Number of timesteps',
     &        'between writing of data into',   'stations file.',
     &        'Station Positions File:',   sposnam(1:lstr)
          lstr=lenstr(staname)
          MPI_master_only write(stdout,'(2x,A,2x,A)')
     &                  'Stations History File:', staname(1:lstr)
#endif

#ifdef FLOATS
!
! Floats file name.
!
      elseif (keyword(1:kwlen).eq.'floats') then
        call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) ldefflt, nflt, nrpfflt
          read(input,'(A)',err=95) fposnam
          read(input,'(A)',err=95) fname
          lstr=lenstr(fname)
# if defined MPI && defined PARALLEL_FILES
          call insert_node (fposname, lstr, mynode, NNODES, ierr)
# endif
          fltname=fname(1:lstr)
          MPI_master_only write(stdout,
     &              '(9x,A,2x,A,2x,A,1x,L1,2x,A,I4,2x,A,I3)')
     &        'Float File:',fltname(1:lstr),  'Create new:',
     &        ldefflt, 'nflt =', nflt, 'rec/file =', nrpfflt
!
! Switches for fields to be saved into floats output file.
!
      elseif (keyword(1:kwlen).eq.'float_fields') then
        call cancel_kwd (keyword(1:kwlen), ierr)
# ifdef AGRIF
        if (Agrif_Root()) then
# endif
          read(input,*,err=95) wrtflt(indxfltGrd),
     &       wrtflt(indxfltTemp), wrtflt(indxfltSalt),
     &       wrtflt(indxfltRho),  wrtflt(indxfltVel)
          MPI_master_only write(stdout,'(/1x,A,5(/6x,l1,2x,A))')
     &      'Fields to be saved in floats output  (T/F)'
     &     , wrtflt(indxfltGrd),   'write Grid location variables'
     &     , wrtflt(indxfltTemp),  'write temperature.'
     &     , wrtflt(indxfltSalt),  'write salinity.'
     &     , wrtflt(indxfltRho),   'write density.'
     &     , wrtflt(indxfltVel),   'write mean float velocity'
# ifdef AGRIF
        endif
# endif
#endif /* FLOATS */

#ifdef ASSIMILATION
!
! Assimilation input/output file names.
!
        elseif (keyword(1:kwlen).eq.'assimilation') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,'(A)',err=95) aparnam
          read(input,'(A)',err=95) assname
          fname=aparnam
          lstr=lenstr(aparnam)
          open (testunit,file=aparnam(1:lstr),status='old',err=97)
          close(testunit)
          MPI_master_only write(stdout,'(1x,A,2x,A)')
     &           'Assimilation Parameters File:', aparnam(1:lstr)
          fname=assname
          lstr=lenstr(assname)
          open (testunit,file=assname(1:lstr),status='old',err=97)
          close(testunit)
          MPI_master_only write(stdout,'(12x,A,2x,A)')
     &                      'Assimilation File:', assname(1:lstr)
#endif
!
! Switches for fields to be saved into history file.
!
        elseif (keyword(1:kwlen).eq.'primary_history_fields') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) wrthis(indxZ),  wrthis(indxUb)
     &                                         ,  wrthis(indxVb)
#ifdef SOLVE3D
     &                      ,  wrthis(indxU),  wrthis(indxV)
     &                      , (wrthis(itrc), itrc=indxT,indxT+NT-1)
# ifdef SEDIMENT_BIOLOGY
     &                      , (wrthis(itrc), 
     &                         itrc=indxSedOrgN,indxSedOrgN+NT_sed-1)
# endif /* SEDIMENT_BIOLOGY */
#endif
          if ( wrthis(indxZ) .or. wrthis(indxUb) .or. wrthis(indxVb)
#ifdef SOLVE3D
     &                          .or. wrthis(indxU) .or. wrthis(indxV)
#endif
     &       ) wrthis(indxTime)=.true.
 
          MPI_master_only write(stdout,'(/1x,A,5(/6x,l1,2x,A,1x,A))')
     &    'Fields to be saved in history file: (T/F)'
     &    , wrthis(indxZ),  'write zeta ', 'free-surface.'
     &    , wrthis(indxUb), 'write UBAR ', '2D U-momentum component.'
     &    , wrthis(indxVb), 'write VBAR ', '2D V-momentum component.'
#ifdef SOLVE3D
     &    , wrthis(indxU),  'write U    ', '3D U-momentum component.'
     &    , wrthis(indxV),  'write V    ', '3D V-momentum component.'
          do itrc=1,NT
            if (wrthis(indxT+itrc-1)) wrthis(indxTime)=.true.
            MPI_master_only write(stdout, '(6x,L1,2x,A,I2,A,I2,A)')
     &                       wrthis(indxT+itrc-1), 'write T(', itrc,
     &                                ')  Tracer of index ', itrc,'.'
          enddo
# ifdef SEDIMENT_BIOLOGY
          do itrc = 1, NT_sed
            if (wrthis(indxSedOrgN+itrc-1)) wrthis(indxTime)=.true.
            MPI_master_only write(stdout, '(6x,L1,2x,A,I2,A,I2,A)')
     &           wrthis(indxSedOrgN+itrc-1), 'write T_sed(', 
     &           itrc,')  Sediment tracer of index ', itrc,'.' 
          end do
# endif /* SEDIMENT_BIOLOGY */
 
        elseif (keyword(1:kwlen).eq.'auxiliary_history_fields') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) wrthis(indxR), wrthis(indxO)
     &          ,  wrthis(indxW),  wrthis(indxAkv),  wrthis(indxAkt)
# ifdef KPP_DIAGNOSE
     &          ,  wrthis(indxRich), wrthis(indxRichN)
# endif
# ifdef SALINITY
     &                                            ,  wrthis(indxAks)
#  ifdef LMD_KPP
     &                                            ,  wrthis(indxHbl)
#  endif
# ifdef LMD_BKPP
     &                                            ,  wrthis(indxHbbl)
# endif
# endif
          if ( wrthis(indxR) .or. wrthis(indxO) .or. wrthis(indxW)
     &                     .or. wrthis(indxAkv) .or. wrthis(indxAkt)
# ifdef KPP_DIAGNOSE
     &                     .or. wrthis(indxRich) .or. wrthis(indxRichN)
# endif
# ifdef SALINITY
     &                                          .or. wrthis(indxAks)
#  ifdef LMD_KPP
     &                                          .or. wrthis(indxHbl)
#  endif
# ifdef LMD_BKPP
     &                                          .or. wrthis(indxHbbl)
# endif
# endif
     &       ) wrthis(indxTime)=.true.
 
          MPI_master_only write(stdout,'(7(/6x,l1,2x,A,1x,A))')
     &      wrthis(indxR),  'write RHO  ', 'Density anomaly'
     &    , wrthis(indxO),  'write Omega', 'Omega vertical velocity.'
     &    , wrthis(indxW),  'write W    ', 'True vertical velocity.'
     &    , wrthis(indxAkv),'write Akv  ', 'Vertical viscosity'
     &    , wrthis(indxAkt),'write Akt  ',
     &                        'Vertical diffusivity for temperature.'
# ifdef KPP_DIAGNOSE
     &    , wrthis(indxRich), 'write Rich ', 
     &               'Diffusivity due to vertical velocity shear'
     &    , wrthis(indxRichN), 'write RichN', 
     &               'Local gradient Richardson number'
# endif
# ifdef SALINITY
     &    , wrthis(indxAks),'write Aks  ',
     &                           'Vertical diffusivity for salinity.'
# endif
# ifdef LMD_KPP
     &    , wrthis(indxHbl),'write Hbl  ',
     &                            'Depth of KPP-model boundary layer'
# endif
# ifdef LMD_BKPP
     &    , wrthis(indxHbbl),'write Hbbl ',
     &                           'Depth of BOTTOM-KPP boundary layer.'
# endif
#endif /* SOLVE3D */
#ifdef AVERAGES
!
! Switches for fields to be saved into averages file.
!
        elseif (keyword(1:kwlen).eq.'primary_averages') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) wrtavg(indxZ),  wrtavg(indxUb)
     &                                         ,  wrtavg(indxVb)
# ifdef SOLVE3D
     &                      ,  wrtavg(indxU),  wrtavg(indxV)
     &                      , (wrtavg(itrc), itrc=indxT,indxT+NT-1)
#  ifdef SEDIMENT_BIOLOGY
     &                      , (wrtavg(itrc), 
     &                         itrc=indxSedOrgN,indxSedOrgN+NT_sed-1)
#  endif /* SEDIMENT_BIOLOGY */
# endif
          if ( wrtavg(indxZ) .or. wrtavg(indxUb) .or. wrtavg(indxVb)
# ifdef SOLVE3D
     &                         .or. wrtavg(indxU) .or. wrtavg(indxV)
# endif
     &       ) wrtavg(indxTime)=.true.
 
# ifdef SOLVE3D
#  ifndef SLICE_AVG 
          MPI_master_only write(stdout,'(/1x,A,5(/6x,l1,2x,A,1x,A))')
     &    'Fields to be saved in averages file: (T/F)'
     &    , wrtavg(indxZ),  'write zeta ', 'free-surface.'
     &    , wrtavg(indxUb), 'write UBAR ', '2D U-momentum component.'
     &    , wrtavg(indxVb), 'write VBAR ', '2D V-momentum component.'
     &    , wrtavg(indxU),  'write U    ', '3D U-momentum component.'
     &    , wrtavg(indxV),  'write V    ', '3D V-momentum component.'
          do itrc=1,NT
            if (wrtavg(indxT+itrc-1)) wrtavg(indxTime)=.true.
            MPI_master_only write(stdout,
     &                       '(6x,L1,2x,A,I2,A,2x,A,I2,A)')
     &                        wrtavg(indxT+itrc-1), 'write T(',
     &                        itrc,')', 'Tracer of index ', itrc,'.'
          enddo
#  ifdef SEDIMENT_BIOLOGY
          do itrc = 1, NT_sed
            if (wrtavg(indxSedOrgN+itrc-1)) wrtavg(indxTime)=.true.
            MPI_master_only write(stdout, '(6x,L1,2x,A,I2,A,I2,A)')
     &           wrtavg(indxSedOrgN+itrc-1), 'write T_sed(', 
     &           itrc,')  Sediment tracer of index ', itrc,'.' 
          end do
#  endif /* SEDIMENT_BIOLOGY */

#  else /* case SLICE_AVG defined */
!
! Switches for fields to be saved into 2D slice averages file.
!
        elseif (keyword(1:kwlen).eq.'primary_slice_avg') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) wrtslavg(indxZ),  wrtslavg(indxUb)
     &                                         ,  wrtslavg(indxVb)
     &                      ,  wrtslavg(indxU),  wrtslavg(indxV)
     &                      , (wrtslavg(itrc), itrc=indxT,indxT+NT-1)
#  ifdef SEDIMENT_BIOLOGY
     &                      , (wrtslavg(itrc), 
     &                         itrc=indxSedOrgN,indxSedOrgN+NT_sed-1)
#  endif /* SEDIMENT_BIOLOGY */
         do itrc = 1,NT+5 
#  ifdef SEDIMENT_BIOLOGY
     &                 + NT_sed
#  endif
         enddo
          if ( wrtslavg(indxZ) .or. wrtslavg(indxUb) .or. 
     &       wrtslavg(indxVb) .or. wrtslavg(indxU) .or. wrtslavg(indxV)
     &       ) wrtslavg(indxTime)=.true.
          
 
          MPI_master_only write(stdout,
     &                   '(/1x,A,5(/6x,L1,A,L1,2x,A,1x,A))')
     &    'Fields to be saved in averages, slice averages file: (T/F)'
     &    , wrtavg(indxZ),', ',  wrtslavg(indxZ)
     &    ,  'write zeta ', 'free-surface.'
     &    , wrtavg(indxUb),', ', wrtslavg(indxUb)
     &    , 'write UBAR ', '2D U-momentum component.'
     &    , wrtavg(indxVb),', ', wrtslavg(indxVb)
     &    , 'write VBAR ', '2D V-momentum component.'
     &    , wrtavg(indxU),', ',  wrtslavg(indxU)
     &    ,  'write U    ', '3D U-momentum component.'
     &    , wrtavg(indxV),', ',  wrtslavg(indxV)
     &    ,  'write V    ', '3D V-momentum component.'
          do itrc=1,NT
            if (wrtslavg(indxT+itrc-1)) wrtslavg(indxTime)=.true.
            MPI_master_only write(stdout,
     &                       '(6x,L1,A,L1,2x,A,I2,A,2x,A,I2,A)')
     &          wrtavg(indxT+itrc-1),', ', wrtslavg(indxT+itrc-1)
     &          , 'write T(', itrc,')', 'Tracer of index ', itrc,'.'
          enddo
#  ifdef SEDIMENT_BIOLOGY
          do itrc = 1, NT_sed
            if (wrtslavg(indxSedOrgN+itrc-1)) wrtslavg(indxTime)=.true.
            MPI_master_only write(stdout, '(6x,L1,2x,A,I2,A,I2,A)')
     &           wrtslavg(indxSedOrgN+itrc-1), 'write T_sed(', 
     &           itrc,')  Sediment tracer of index ', itrc,'.' 
          end do
#  endif /* SEDIMENT_BIOLOGY */
#  endif /*  SLICE_AVG  */
 
        elseif (keyword(1:kwlen).eq.'auxiliary_averages') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) wrtavg(indxR), wrtavg(indxO)
     &          ,  wrtavg(indxW),  wrtavg(indxAkv),  wrtavg(indxAkt)
#  ifdef KPP_DIAGNOSE
     &          ,  wrtavg(indxRich), wrtavg(indxRichN)
#  endif
#  ifdef SALINITY
     &                                            ,  wrtavg(indxAks)
#  endif
#  ifdef LMD_KPP
     &                                            ,  wrtavg(indxHbl)
#  endif
#  ifdef LMD_BKPP
     &                                            ,  wrtavg(indxHbbl)
#  endif
          if ( wrtavg(indxR) .or. wrtavg(indxO) .or. wrtavg(indxW)
     &                  .or. wrtavg(indxAkv) .or. wrtavg(indxAkt)
#  ifdef KPP_DIAGNOSE
     &                  .or. wrtavg(indxRich) .or. wrtavg(indxRichN)
#  endif
#  ifdef SALINITY
     &                                          .or. wrtavg(indxAks)
#  endif
#  ifdef LMD_KPP
     &                                          .or. wrtavg(indxHbl)
#  endif
#  ifdef LMD_BKPP
     &                                          .or. wrtavg(indxHbbl)
#  endif
     &       ) wrtavg(indxTime)=.true.
 
#  ifndef SLICE_AVG
          MPI_master_only write(stdout,'(7(/6x,l1,2x,A,1x,A))')
     &      wrtavg(indxR),  'write RHO  ', 'Density anomaly'
     &    , wrtavg(indxO),  'write Omega', 'Omega vertical velocity.'
     &    , wrtavg(indxW),  'write W    ', 'True vertical velocity.'
     &    , wrtavg(indxAkv),'write Akv  ', 'Vertical viscosity'
     &    , wrtavg(indxAkt),'write Akt  ',
     &                        'Vertical diffusivity for temperature.'
#  ifdef KPP_DIAGNOSE
     &    , wrtavg(indxRich), 'write Rich ', 
     &                'Diffusivity due to vertical velocity shear'
     &    , wrtavg(indxRichN), 'write RichN', 
     &               'Local gradient Richardson number'
#  endif
#  ifdef SALINITY
     &    , wrtavg(indxAks),'write Aks  ',
     &                           'Vertical diffusivity for salinity.'
#  endif
#  ifdef LMD_KPP
     &    , wrtavg(indxHbl),'write Hbl  ',
     &                            'Depth of KPP-model boundary layer'
#  endif
#  ifdef LMD_BKPP
     &    , wrtavg(indxHbbl),'write Hbbl ',
     &                            'Depth of BOTTOM-KPP boundary layer'
#  endif
#  else /* SLICE_AVG defined */
        elseif (keyword(1:kwlen).eq.'auxiliary_slice_avg') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) wrtslavg(indxR), wrtslavg(indxO)
     &         , wrtslavg(indxW), wrtslavg(indxAkv), wrtslavg(indxAkt)
#  ifdef KPP_DIAGNOSE
     &          ,  wrtslavg(indxRich), wrtslavg(indxRichN)
#  endif
#  ifdef SALINITY
     &                                            ,  wrtslavg(indxAks)
#  endif
#  ifdef LMD_KPP
     &                                            ,  wrtslavg(indxHbl)
#  endif
#  ifdef LMD_BKPP
     &                                            ,  wrtslavg(indxHbbl)
#  endif
         if ( wrtslavg(indxR) .or. wrtslavg(indxO) .or. wrtslavg(indxW)
     &                .or. wrtslavg(indxAkv) .or. wrtslavg(indxAkt)
#  ifdef KPP_DIAGNOSE
     &                .or. wrtslavg(indxRich) .or. wrtslavg(indxRichN)
#  endif
#  ifdef SALINITY
     &                                          .or. wrtslavg(indxAks)
#  endif
#  ifdef LMD_KPP
     &                                          .or. wrtslavg(indxHbl)
#  endif
#  ifdef LMD_BKPP
     &                                          .or. wrtslavg(indxHbbl)
#  endif
     &       ) wrtslavg(indxTime)=.true.
 
          MPI_master_only write(stdout,'(A,7(/6x,l1,1x,l1,2x,A,1x,A))')
     &    'Fields to be saved in averages, slice averages file: (T/F)'
     &      , wrtavg(indxR), wrtslavg(indxR)
     &      , 'write RHO  ', 'Density anomaly'
     &      , wrtavg(indxO), wrtslavg(indxO)
     &      ,  'write Omega', 'Omega vertical velocity.'
     &      , wrtavg(indxW), wrtslavg(indxW)
     &      ,  'write W    ', 'True vertical velocity.'
     &      , wrtavg(indxAkv), wrtslavg(indxAkv)
     &      ,'write Akv  ', 'Vertical viscosity'
     &      , wrtavg(indxAkt), wrtslavg(indxAkt)
     &      ,'write Akt  ', 'Vertical diffusivity for temperature.'
#  ifdef KPP_DIAGNOSE
     &      , wrtavg(indxRich), wrtslavg(indxRich)
     &      , 'write Rich ', 'Diffusivity due to vertical shear'
     &      , wrtavg(indxRichN), wrtslavg(indxRichN)
     &      , 'write RichN', 'Local gradient Richardson number'
#  endif
#  ifdef SALINITY
     &      , wrtavg(indxAks), wrtslavg(indxAks)
     &      , 'write Aks  ', 'Vertical diffusivity for salinity.'
#  endif
#  ifdef LMD_KPP
     &      , wrtavg(indxHbl), wrtslavg(indxHbl)
     &      , 'write Hbl  ', 'Depth of KPP-model boundary layer'
#  endif
#  ifdef LMD_BKPP
     &      , wrtavg(indxHbbl), wrtslavg(indxHbbl)
     &      , 'write Hbbl ', 'Depth of BOTTOM-KPP boundary layer'
#  endif
#  endif /* SLICE_AVG */
# endif /* SOLVE3D */
#endif /* AVERAGES */


#ifdef UV_VIS2
!
! Horizontal viscosity coefficients.
!
        elseif (keyword(1:kwlen).eq.'lateral_visc') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) visc2
          MPI_master_only write(stdout,'(1pe10.3,2x,A,6x,A)') visc2, 
     &    'visc2', 'Horizontal Laplacian kinematic viscosity [m2/s].'
#endif
!
! Bottom drag coefficients.
!
        elseif (keyword(1:kwlen).eq.'bottom_drag') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) rdrg, rdrg2
          MPI_master_only write(stdout,'((1pe10.3,2x,A))')
     &      rdrg, 'rdrg     Linear bottom drag coefficient, m/s.',
     &      rdrg2,'rdrg2    Quadratic bottom drag coefficient.'
!
! Lateral boundary slipperness.
!
        elseif (keyword(1:kwlen) .eq. 'gamma2') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) gamma2
          MPI_master_only write(stdout,'(f10.2,2x,A,1x,A)')
     &       gamma2, 'gamma2   Slipperiness parameter:',
     &                       'free-slip +1, or no-slip -1.'
#ifdef SOLVE3D
!
! Boussinesque Approximation mean density.
!
        elseif (keyword(1:kwlen) .eq. 'rho0') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) rho0
          MPI_master_only write(stdout,'(F10.4,2x,A,1x,A)')
     &          rho0, 'rho0     Boussinesque approximation',
     &                                'mean density, kg/m3.'

# ifndef NONLIN_EOS
!
! Parameters for linear equations of state.
!
        elseif (keyword(1:kwlen).eq.'lin_EOS_cff') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) R0, T0, Tcoef
#  ifdef SALINITY
     &                           , S0, Scoef
#  endif
          MPI_master_only write(stdout,'(5(f10.4,2x,A,1x,A/))')
     &       R0, 'R0       Background density in linear EOS',
     &                                                  '[kg/m^3].',
     &       T0, 'T0       Background value for potential',
     &                                 'temperature [deg Celsius].',
     &    Tcoef, 'Tcoef    Thermal expansion coefficient',
     &                                               '[1/Celsius].'
#  ifdef SALINITY
     &   ,   S0, 'S0       Background salinity [PSU],', 'constant.',
     &    Scoef, 'Scoef    Saline contraction coefficient [1/PSU].'
#  endif
# endif
# ifdef TS_DIF2
!
! Horizontal Laplacian mixing coefficients for tracers.
!
        elseif (keyword(1:kwlen).eq.'tracer_diff2') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) (tnu2(itrc),itrc=1,NT)
          do itrc=1,NT
            MPI_master_only write(stdout,7) tnu2(itrc), itrc, itrc
   7        format(1pe10.3,'  tnu2(',i2,')     Horizontal Laplacian '
     &       ,'mixing coefficient (m2/s)',/,32x,'for tracer ',i2,'.')
          enddo
# endif
# if !defined LMD_MIXING && !defined BVF_MIXING\
  && !defined MY2_MIXING && !defined MY25_MIXING\
                         && !defined PP_MIXING
!
! Background vertical viscosity and mixing coefficients for tracers.
!
        elseif (keyword(1:kwlen).eq.'vertical_mixing') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) Akv_bak,(Akt_bak(itrc),itrc=1,NT)
          MPI_master_only write(stdout,'(1pe10.3,2x,A,1x,A)')
     &        Akv_bak, 'Akv_bak    Background vertical viscosity',
     &                                       'coefficient, m2/s.'
          do itrc=1,NT
            MPI_master_only write(stdout,
     &             '(1pe10.3,2x,A,I1,A,1x,A/32x,A,I3,A)')
     &              Akt_bak(itrc), 'Akt_bak(', itrc, ')',
     &             'Background vertical mixing coefficient, m2/s,',
     &                                    'for tracer ', itrc, '.'
          enddo
# endif
# ifdef MY25_MIXING
!
! Mellor-Yamada Level 2.5 turbulent closure parameters.
!
        elseif (keyword(1:kwlen).eq.'MY_bak_mixing') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) Akq_bak, q2nu2, q2nu4
          MPI_master_only write(stdout,13) Akq_bak
  13      format(1pe10.3,2x,'Akq_bak     Background vertical mixing',
     &          ' coefficient [m2/s]',/,32x,'for turbulent energy.')
#  ifdef Q_DIF2
          MPI_master_only write(stdout,14) q2nu2
  14      format(1pe10.3,2x,'q2nu2       Horizontal Laplacian ',
     &    'mixing coefficient [m2/s]',/,32x,'for turbulent energy.')
#  endif
#  ifdef Q_DIF4
          MPI_master_only write(stdout,15) q2nu4
  15      format(1pe10.3,2x,'q2nu4       Horizontal, biharmonic ',
     &    'mixing coefficient, m2/s,',/,32x,'for turbulent energy.')
#  endif
# endif
#endif /* SOLVE3D */
#ifdef SPONGE
!
! Parameters for the sponge layers
!
#if defined OLD_SPONGE_DEFAULT || defined BENGUELA || PACIFIC
         elseif (keyword(1:kwlen).eq.'v_sponge') then
           call cancel_kwd (keyword(1:kwlen), ierr)
           read(input,*,err=95) v_sponge
#else
         elseif (keyword(1:kwlen).eq.'sponge') then
           call cancel_kwd (keyword(1:kwlen), ierr)
           read(input,*,err=95) n_sponge,v_sponge
           MPI_master_only write(stdout,'(1pe10.2,2x,A)') n_sponge
     &       ,'n_sponge Number of grid lines in sponge layer [-]'
#endif
           MPI_master_only write(stdout,'(f10.2,2x,A)')
     &       v_sponge,'v_sponge Viscosity in sponge layer (m2/s)'
# endif

#if  defined T_FRC_BRY || defined M2_FRC_BRY || defined TNUDGING \
  || defined Z_FRC_BRY || defined M3_FRC_BRY || defined M2NUDGING \
                                             || defined M3NUDGING
!
! Parameters for OBC nudging and nudging layers;
! converted from [days] to [sec^-1]
!
        elseif (keyword(1:kwlen).eq.'nudg_cof') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) tauM2_in, tauM2_out, attnM2
# ifdef SOLVE3D
     &                       , tauM3_in, tauM3_out
     &                       , tauT_in,  tauT_out
# endif
          if (tauM2_in.gt.0.) then               ! convert from
            tauM2_in =1./(tauM2_in *day2sec)     ! relaxation time
          endif                                  ! units into nudging
          if (tauM2_out.gt.0.) then              ! intensity
            tauM2_out=1./(tauM2_out*day2sec)     ! coefficients
          endif
# ifdef SOLVE3D
          if (tauM3_in.gt.0.) then
            tauM3_in =1./(tauM3_in *day2sec)
          endif
          if (tauM3_out.gt.0.) then
            tauM3_out=1./(tauM3_out*day2sec)
          endif
          if (tauT_in.gt.0.) then
            tauT_in =1./(tauT_in *day2sec)
          endif
          if (tauT_out.gt.0.) then
            tauT_out=1./(tauT_out*day2sec)
          endif
# endif
          MPI_master_only write(stdout,'(1pe10.3,1x,1pe10.3,2x,2A)')
     &              tauM2_in,tauM2_out,  'tauM2_in/out  Nudging ',
     &              'intencities for barotropic mode [sec^-1]'
          MPI_master_only write(stdout,'(1pe10.3,2x,2A)') attnM2,
     &      ' attnM2  open boundary PG-term attenuation coefficient'
# ifdef SOLVE3D
          MPI_master_only write(stdout,'(1pe10.3,1x,1pe10.3,2x,2A)')
     &              tauM3_in, tauM3_out,  'tauM3_in/out  Nudging ',
     &              'intencities for baroclinic mode [sec^-1]'
          MPI_master_only write(stdout,'(1pe10.3,1x,1pe10.3,2x,2A)')
     &              tauT_in,tauT_out, 'tauT_in/out   Nudging ',
     &              'intencities for tracers [sec^-1]'
# endif
#endif
#ifdef OBC_FLUX_CORR
        elseif (keyword(1:kwlen).eq.'tau_obc') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) tau_obc
          MPI_master_only write(stdout,'(1pe10.3,2x,A,1x,A)')
     &       tau_obc, 'tau_obc   OBC volume constraint',
     &                              'relaxation period [days]'
          tau_obc=tau_obc*day2sec
#endif
!DL: keywords related to interannual variations of atm. pCO2:
#if (defined BIOLOGY_BEC || defined BIOLOGY_BEC2 || defined BIOLOGY_NPZDOC)\
    && defined VARIABLE_ANN_ATM_PCO2
        elseif (keyword(1:kwlen).eq.'start_year') then
          ! Year at which the simulation starts. This is needed for
          ! the computation of the atmospheric pCO2. It can be a 
          ! floating point number, e.g. 2002.5 if the run starts in
          ! the middle of 2002.
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) start_year
          MPI_master_only write(stdout,'(1pe10.3,2x,A,1x,A)')
     &       start_year, 'start_year   point in time (year) when',
     &       'simulation starts'
!        elseif (keyword(1:kwlen).eq.'futr_scen') then
!          ! Scenario used for computing future (i.e. past 1990.5) values
!          ! of pCO2. Must be one of the following: S350, S450, S550,
!          ! S650, S750, DS450, or DS550 from Enting et al. (1994), 
!          ! or CIS9 signifying c-IS92A for IPCC (2000) run.
!          call cancel_kwd (keyword(1:kwlen), ierr)
!          read(input,*,err=95) futr_scen
!          ! Test whether futr_scen contains a valid string:
!          futr_scen_valid = .false.
!          if (futr_scen(1:4) .eq. 'S350' .or. futr_scen(1:4) .eq. 'S450' .or.
!     &        futr_scen(1:4) .eq. 'S550' .or. futr_scen(1:4) .eq. 'S650' .or.
!     &        futr_scen(1:4) .eq. 'S750' .or. futr_scen(1:4) .eq. 'DS45' .or.
!     &        futr_scen(1:4) .eq. 'DS55' .or. futr_scen(1:4) .eq. 'CIS9')
!     &          futr_scen_valid = .true.
!          if (.not. futr_scen_valid) then
!             MPI_master_only write(stdout,'(3a)') 'Invalid value of ',
!     &       'futr_scen: ', futr_scen
!             goto 95
!          end if
!          MPI_master_only write(stdout,'(6x,A,2x,A,1x,A)')
!     &      futr_scen , 'futr_scen   scenario for past 1990.5 values',
!     &      'of atm. pCO2'
#endif /* BIOLOGY_BEC || BIOLOGY_BEC2 || BIOLOGY_NPZDOC) && VARIABLE_ANN_ATM_PCO2
!DL: age/dye tracers:
#if defined PASSIVE_TRACER && defined AGE_DYE_TRACER
        elseif (keyword(1:kwlen).eq.'age_dye') then
           call cancel_kwd (keyword(1:kwlen), ierr)
           ! Read number of age/dye tracers:
           read(input,*,err=95) N_agedye
           if (N_agedye .gt. ntrc_pas) then
              MPI_master_only write(stdout,'(3a,i6)') 'ERROR: ',
     &        'too many age/dye tracers. Set parameter ntrc_pas ',
     &        'in param.h to a value >= ', N_agedye
              goto 95
           end if
           MPI_master_only write(stdout,'(6x,i2,A)')
     &          N_agedye, ' Number of age/dye tracers'
#endif /* PASSIVE_TRACER && AGE_DYE_TRACER */
        else
          MPI_master_only write(stdout,'(/1x,4A/)') 'WARNING: ',
     &                'Unrecognized keyword ''', keyword(1:kwlen),
     &                                      ''' --> DISREGARDED.'
        endif
       if (keyword(1:kwlen) .eq. end_signal) goto 99
      goto 1
!
! Error while reading input parameters.
!
  95  write(stdout,'(/1x,4A/)') 'READ_INP ERROR while reading block',
     &                    ' with keyword ''', keyword(1:kwlen), '''.'
      ierr=ierr+1
      goto 99
  97  lstr=lenstr(fname)
      write(stdout,'(/1x,4A/)') 'READ_INP ERROR: Cannot find input ',
     &                                'file ''', fname(1:lstr), '''.'
      ierr=ierr+1
  99  close (input)
!
! Check that all keywords were canceled, complain about the error,
! if some of them left.
!
      if (ierr.eq.0) then
        call check_kwds (ierr)
#ifdef STATIONS
        call sta_inp (ierr)       ! <-- read in station positions.
#endif
      endif
      if (ierr.ne.0) then
        write(stdout,'(/1x,2A,I3,1x,A/)') 'READ_INP ERROR: ',
     & 'A total of', ierr, 'configuration errors discovered.'
       return
      endif
      call check_srcs
#ifdef MPI
      call MPI_Barrier (ocean_grid_comm, ierr)
#endif
      MPI_master_only print '(/3A)', '------------'
     &    , ' Finished reading input parameters ', '------------'
      return
      end

                                           ! Find place in the string
      subroutine cancel_kwd (keyword, ierr)! kwds(1:max_opt_size)
      implicit none                        ! which matches the input
#include "strings.h"
      character*(*) keyword                ! keyword and turn it to
      integer ierr, is,i,ie, lenkw,lenstr  ! to blank. Complain about
      lenkw=lenstr(keyword)                ! error, if not found.
      is=1
      do while (is.gt.0 .and. is.lt.max_opt_size)
        do while (kwds(is:is).eq.' ' .and. is.lt.max_opt_size)
          is=is+1
        enddo
        ie=is+1
        do while (kwds(ie:ie).ne.' ' .and. ie.lt.max_opt_size)
          ie=ie+1
        enddo
        if (lenkw.eq.ie-is .and. kwds(is:ie-1).eq.keyword) then
c**       write(*,'(1x,A,1x,A)') 'Recognized: ', kwds(is:ie-1)
          do i=is,ie-1
            kwds(i:i)=' '
          enddo
          is=0         !--> to signal that keyword is found and
        else           !                      terminate the search
          is=ie        !--> skip to the next word in "kwds" string
        endif
      enddo
      if (is.ne.0) then
        write(*,'(/A)') '##### ERROR #####'
        write(*,'(2(1x,A,1x,A,1x,A/)/)') 'cancel_kwd:',
     &         'Can not cancel keyword:',  keyword(1:lenkw),
     &         'check input script for possible',
     &         'duplicated keywords.'
        write(*,'(A/)') '#################'
        ierr=ierr+1
      endif
      return
      end

                                      ! Check that keyword string is
      subroutine check_kwds (ierr)    ! empty, and if it is not print
      implicit none                   ! out remaining keyword(s) as
#include "strings.h"
      integer ierr, is,ie             ! an error message and increase
      is=1                            ! error counter ierr.
      do while (is.lt.max_opt_size)
        do while (kwds(is:is).eq.' ' .and. is.lt.max_opt_size)
          is=is+1
        enddo
        if (is.lt.max_opt_size) then
          ie=is+1
          do while (kwds(ie:ie).ne.' ' .and. ie.lt.max_opt_size)
            ie=ie+1
          enddo
          ierr=ierr+1
          write(*,'(/1x,A,1x,A/)') 'ERROR: keyword not found:',
     &                                          kwds(is:ie-1)
          is=ie
        endif
      enddo
      return
      end
 
 
